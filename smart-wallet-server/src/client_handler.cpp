#include "client_handler.h"

ClientHandler::ClientHandler(ThreadSafeQueue<Transaction>* logging_queue, DBParams db_params)
{
	mysql_conn_ = mysql_init(NULL);
	
	// Connect to DB
        if(!mysql_real_connect(mysql_conn_,
                               db_params.ip.c_str(),
                               db_params.user.c_str(),
                               db_params.password.c_str(),
                               db_params.db_name.c_str(), 0, NULL, 0))
	{
		perror(mysql_error(mysql_conn_));
	}

	logging_queue_ = logging_queue;
}

ClientHandler::~ClientHandler()
{
	// Close DB connection
	mysql_free_result(mysql_res_);
	mysql_close(mysql_conn_);
}

int ClientHandler::getClientInfo(unsigned long national_id, ClientInfo& client_info)
{
	std::string query = "select * from customer where national_id = " + std::to_string(national_id);

	std::cout << "DB Query: " << query << std::endl;
	
	if(mysql_query(mysql_conn_, query.c_str()))
	{
		perror(mysql_error(mysql_conn_));
		return -1;
	}
	
	// Get query result
	mysql_res_ = mysql_store_result(mysql_conn_);

	unsigned int rows_cnt = mysql_num_rows(mysql_res_);
	if(rows_cnt != 1)
	{
		std::cout << "Error: " << rows_cnt << " rows with the same national_id\n";
		return -2;
	}
	else
	{
		mysql_row_ = mysql_fetch_row(mysql_res_);
		client_info.id = strtoul(mysql_row_[0], NULL, 10);
		client_info.name = mysql_row_[1];
		client_info.national_id = strtoul(mysql_row_[2], NULL, 10);
		client_info.age = atoi(mysql_row_[3]);
		client_info.balance = strtoull(mysql_row_[4], NULL, 10);
	}

	return 0;;
}

bool ClientHandler::isValidId(std::string id)
{
   return (id.find_first_not_of("0123456789") == std::string::npos)
            && (id.length() == 14);
}

bool ClientHandler::isValidAge(int age)
{
	// TODO: Check age correctly
        return (age > MIN_AGE && age < MAX_AGE);
}

bool ClientHandler::createNewAccount(const ClientInfo& client_info)
{	
	std::string query = "insert into customer(name, national_id, age, gender, balance) "
					  	"values('" + client_info.name + "',"
					  	+ std::to_string(client_info.national_id) + ","
					  	+ std::to_string(client_info.age) + ",'"
					  	+ client_info.gender +"',0)";

	std::cout << "DB Query: " << query << std::endl;

	if(mysql_query(mysql_conn_, query.c_str()))
	{
		perror(mysql_error(mysql_conn_));
		return false;
	}

	// Store info in RAM
	client_info_ = client_info;

	// Get the autogenerated id after inserting row
	query = "select id from customer where national_id = "
		    + std::to_string(client_info.national_id);

	if(mysql_query(mysql_conn_, query.c_str()))
	{
		perror(mysql_error(mysql_conn_));
		return false;
	}

	// Get query result
	mysql_res_ = mysql_store_result(mysql_conn_);
	// res = mysql_use_result(conn);

	unsigned int rows_cnt = mysql_num_rows(mysql_res_);
	if(rows_cnt != 1)
	{
		std::cout << "Error: " << rows_cnt << " rows returned\n";
	}
	else
	{
		mysql_row_ = mysql_fetch_row(mysql_res_);
		client_info_.id = strtoul(mysql_row_[0], NULL, 10);

		std::cout << "Autogenerated id = " << client_info_.id << std::endl;
	}

	return true;
}

std::string getCurrentTime()
{
	std::time_t rawtime;
    std::tm* timeinfo;
    char buffer[80];
    std::string time;

    std::time(&rawtime);
    timeinfo = std::localtime(&rawtime);

    std::strftime(buffer,80,"%Y-%m-%d %H:%M:%S",timeinfo);
    return std::string(buffer);
}

bool ClientHandler::deposit(unsigned long long amount)
{
	std::string query = "update customer set balance = balance + " + std::to_string(amount)
					  + " where id = " + std::to_string(client_info_.id);

	std::cout << "DB Query: " << query << std::endl;

	if(mysql_query(mysql_conn_, query.c_str()))
	{
		perror(mysql_error(mysql_conn_));
		return false;
	}

	std::string date = getCurrentTime();

	query = "insert into transaction(customer_id, type, amount, date)"
		  	" values(" + std::to_string(client_info_.id) + ",'DEPOSIT'," + std::to_string(amount)
		  + ",'" + date +"')";
					 

	std::cout << "DB Query: " << query << std::endl;

	if(mysql_query(mysql_conn_, query.c_str()))
	{
		perror(mysql_error(mysql_conn_));
		return false;
	}

	// Push transaction to be logged by the logging thread
	Transaction transaction;
	transaction.customer_name = client_info_.name;
	transaction.customer_id = client_info_.id;
	transaction.type = DEPOSIT;
	transaction.amount = amount;
	transaction.date = date;
	logging_queue_->push(transaction);

	std::cout << "Client " << client_info_.name << " with id = " << client_info_.id
			  << ": DEPOSIT " << amount << "$$ at " << date << std::endl;

	// Update data to be synced with DB
	client_info_.balance += amount;

	return true;
}

bool ClientHandler::withdraw(unsigned long long amount)
{
	std::string query = "update customer set balance = balance - " + std::to_string(amount)
					  + " where id = " + std::to_string(client_info_.id);

	std::cout << "DB Query: " << query << std::endl;
	
	if(mysql_query(mysql_conn_, query.c_str()))
	{
		perror(mysql_error(mysql_conn_));
		return false;
	}

	std::string date = getCurrentTime();

	query = "insert into transaction(customer_id, type, amount, date)"
			" values(" + std::to_string(client_info_.id) + ",'WITHDRAW'," + std::to_string(amount)
			+ ",'" + date +"')";
					 

	std::cout << "DB Query: " << query << std::endl;

	if(mysql_query(mysql_conn_, query.c_str()))
	{
		perror(mysql_error(mysql_conn_));
		return false;
	}

	// Push transaction to be logged by the logging thread
	Transaction transaction;
	transaction.customer_name = client_info_.name;
	transaction.customer_id = client_info_.id;
	transaction.type = WITHDRAW;
	transaction.amount = amount;
	transaction.date = date;
	logging_queue_->push(transaction);

	std::cout << "Client " << client_info_.name << " with id = " << client_info_.id
			  << ": WITHDRAW " << amount << "$$ at " << date << std::endl;

	// Update data to be synced with DB
	client_info_.balance -= amount;

	return true;
}

bool ClientHandler::getBalance(unsigned long long& balance)
{
	std::string query = "select balance from customer where id = "
					  + std::to_string(client_info_.id);

	std::cout << "DB Query: " << query << std::endl;

	if(mysql_query(mysql_conn_, query.c_str()))
	{
		perror(mysql_error(mysql_conn_));
		return false;
	}
	
	// Get query result
	mysql_res_ = mysql_store_result(mysql_conn_);
	// res = mysql_use_result(conn);

	unsigned int rows_cnt = mysql_num_rows(mysql_res_);
	if(rows_cnt != 1)
	{
		std::cout << "Error: " << rows_cnt << " rows with the same id\n";
		return false;
	}
	else
	{
		mysql_row_ = mysql_fetch_row(mysql_res_);
		balance = strtoull(mysql_row_[0], NULL, 10);

		if(client_info_.balance != balance)
		{
			std::cout << "Client balance = " << client_info_.balance
					  << "\nBalance stored in DB = " << balance << std::endl;
		}
	}

	return true;
}

bool ClientHandler::getStats(std::vector<std::string>& transaction_dates,
							 std::vector<unsigned long>& amounts)
{
	std::string query = "select date,amount from transaction where customer_id = "
					  + std::to_string(client_info_.id);

	std::cout << "DB Query: " << query << std::endl;

	if(mysql_query(mysql_conn_, query.c_str()))
	{
		perror(mysql_error(mysql_conn_));
		return false;
	}

	// Get query result
	mysql_res_ = mysql_store_result(mysql_conn_);
	// res = mysql_use_result(conn);

	while(mysql_row_ = mysql_fetch_row(mysql_res_))
	{
		std::string date = mysql_row_[0];
		size_t space = date.find(' ');
		date = date.substr(0, space);
		std::string amount = mysql_row_[1];
		transaction_dates.push_back(date);
		amounts.push_back(stoull(amount));
	}

	return true;
}


void ClientHandler::sendResponse(int sockfd, Response response)
{
	// Setup response (status + message data)
	std::string msg_data(response.data);
	std::string response_content = std::to_string(response.status) + " " + msg_data;
	
	// Send message size first
	sprintf(response.data,"%ld", response_content.length());

	int bytes_cnt = write(sockfd, response.data, sizeof(response.size));
	if (bytes_cnt < 0)
	{
		perror("Write Socket Error");
	}

	// Send message
	strcpy(response.data, response_content.c_str());
	response.size = response_content.length();

	bytes_cnt = write(sockfd, response.data, response.size);
	if (bytes_cnt < 0)
	{
		perror("Write Socket Error");
	}
}

void ClientHandler::recvRequest(int sockfd, Request& request)
{
	// Receive message size first
	int bytes_cnt = read(sockfd, request.data, sizeof(request.size));
	if (bytes_cnt < 0)
	{
		perror("Read Socket Error");
	}

	int msg_size = std::atoi(request.data);

	// Receive message
	bytes_cnt = read(sockfd, request.data, msg_size);
	if (bytes_cnt < 0)
	{
		perror("Read Socket Error");
	}
}

bool ClientHandler::processRequest(Request request, Response& response)
{
	std::string data(request.data);

	// Split data by spaces
	std::istringstream iss(data);
	std::string msg_type, raw_data;
	std::getline(iss, msg_type, ' ');
	std::getline(iss, raw_data, ' ');

	REQUEST_TYPE type = REQUEST_TYPE(std::stoi(msg_type));
	if(type == LOGIN)
	{
		std::cout << "Client Login Request\n";
		std::string national_id = raw_data;

		if(!isValidId(national_id))
		{
			std::cout << "Invalid id. National IDs are 14 characters!\n";
			response.status = INVALID_ID;
		}
		else
		{
			int ret = getClientInfo(std::stoul(national_id), client_info_);
			if(ret == -1)
			{
				std::cout << "Error getting client info from DB\n";
				strcpy(response.data, "Server response: (ERROR) Failure!");
				response.status = FAIL;
			}
			else if(ret == -2)
			{
				std::cout << "Error Client not registered\n";
				strcpy(response.data, "Server response: (ERROR) Client not registered!");
				response.status = FAIL;
			}
			else 
			{
				std::cout << "Client " << client_info_.name << " logged in\n";
				// Send success + client name
				response.status = SUCCESS;
				strcpy(response.data, client_info_.name.c_str());
				response.size = strlen(response.data);
			}
		}
	}
	else if(type == REGISTER)
	{
		std::cout << "Client Register Request\n";
		std::string name, national_id, age, gender;
		name = raw_data;
		std::getline(iss, national_id, ' ');
		std::getline(iss, age, ' ');
		std::getline(iss, gender, ' ');

		if(!isValidId(national_id))
		{
			std::cout << "Invalid id. National IDs are 14 characters!\n";
			response.status = INVALID_ID;
		}
		else if(!isValidAge(std::stoi(age)))
		{
			std::cout << "Invalid age!\n";
			response.status = INVALID_AGE;
		}
		else
		{
			// Create new user
			ClientInfo client_info;
			client_info.name = name;
			client_info.national_id = std::stoul(national_id);
			client_info.age = stoi(age);
			client_info.balance = 0;
			client_info.gender = gender;

			bool ret = createNewAccount(client_info);
			if(!ret)
			{
				std::cout << "Error creating new account\n";
				strcpy(response.data, "Server response: (ERROR) Creating new account");
				response.status = FAIL;
			}
			else 
			{
				std::cout << "New Client registered:\n" 
						  << "Name: " << name
						  << "\nNational ID: " << national_id
						  << "\nAge: " << age
						  << "\nGender: " << gender << std::endl;
				// Send success + client name
				response.status = SUCCESS;
				strcpy(response.data, client_info.name.c_str());
				response.size = strlen(response.data);
			}
		}
	}
	else if(type == DEPOSIT)
	{
		unsigned long long amount = std::stoll(raw_data);

		if (amount <= 0)
		{
			std::cout << "Invalid amount!\n";
			response.status = INVALID_AMOUNT;
		}
		else
		{
			bool ret = deposit(amount);
			if(!ret)
			{
				std::cout << "Error deposit in DB\n";
				strcpy(response.data, "Server response: (ERROR) Processing operation");
				response.status = FAIL;
			}
			else 
			{
				response.status = SUCCESS;
				request.type = type;
				strcpy(request.data, raw_data.c_str());
				undostack_.push(request);
			}
		}
	}
	else if(type == WITHDRAW)
	{
		unsigned long long amount = std::stoll(raw_data);

		if (amount <= 0)
		{
			std::cout << "Invalid amount!\n";
			response.status = INVALID_AMOUNT;
		}
		else
		{	
			// Check for balance first
			unsigned long long balance;
			bool ret = getBalance(balance);
			if(!ret)
			{
				std::cout << "Error getting balance from DB\n";
				strcpy(response.data, "Server response: (ERROR) Processing operation");
				response.status = FAIL;
			}
			else 
			{
				if(amount > balance)
				{
					std::cout << "Not enough money in your account!\n";
					response.status = NOT_ENOUGH_MONEY;
				}
				else
				{
					bool ret = withdraw(amount);
					if(!ret)
					{
						std::cout << "Error withdraw from DB\n";
						strcpy(response.data, "Server response: (ERROR) Processing operation");
						response.status = FAIL;
					}
					else 
					{
						response.status = SUCCESS;
						request.type = type;
						strcpy(request.data, raw_data.c_str());
						undostack_.push(request);
					}
				}
			}
		}
	}
	else if(type == CHECK_BALANCE)
	{
		std::cout << "Client Check Balance Request\n";
		unsigned long long balance;

		bool ret = getBalance(balance);
		if(!ret)
		{
			std::cout << "Error getting balance from DB\n";
			strcpy(response.data, "Server response: (ERROR) Processing operation");
			response.status = FAIL;
		}
		else 
		{
			// Send success + balance
			response.status = SUCCESS;
			strcpy(response.data,  std::to_string(balance).c_str());
			response.size = strlen(response.data);
		}
	}
	else if(type == GET_STATS)
	{
		std::cout << "Client Statistics Request\n";
		std::vector<std::string> transaction_dates;
		std::vector<unsigned long> amounts;

		bool ret = getStats(transaction_dates, amounts);
		if(!ret)
		{
			std::cout << "Error getting dates from DB\n";
			strcpy(response.data, "Server response: (ERROR) Processing operation");
			response.status = FAIL;
		}
		else
		{
			memset(response.data, 0, MSG_MAX_SIZE);

			std::vector<unsigned long> month_rate(13,0);

			for(int i = 0; i < transaction_dates.size(); ++i)
			{
				std::size_t dash1 = transaction_dates[i].find('-');
		        std::string month = transaction_dates[i].substr(dash1+1,2);

		        if(month[0] == '0')
		        {
		        	month_rate[int(month[1]) - '0'] += amounts[i];
		    	}
		    	else
		    	{
		    		month_rate[std::stoi(month)] += amounts[i];
		    	}
			}
		        
			strcpy(response.data, ("1 " + std::to_string(month_rate[1]) + " ").c_str());
			for(int i = 2; i <= 12; ++i)
			{
				strcat(response.data, (std::to_string(i) + " " + std::to_string(month_rate[i]) + " ").c_str());
			}

			// Send success + transaction dates
			response.status = SUCCESS;
			response.size = strlen(response.data);
		}
	}
	else if(type == UNDO)
	{
		std::cout << "Client Undo Request\n";
		Request undo_request = undostack_.top();
		unsigned long long amount = std::stoll(undo_request.data);
	    
	    if(undo_request.type == DEPOSIT)
	    {
	        bool ret = withdraw(amount);
			if(!ret)
			{
				std::cout << "Error withdraw from DB\n";
				strcpy(response.data, "Server response: (ERROR) Processing operation");
				response.status = FAIL;
			}
			else 
			{
				response.status = SUCCESS;
				undostack_.pop();
				redostack_.push(undo_request);
			}
	    }
	    else if(undo_request.type == WITHDRAW)
	    {
	        bool ret = deposit(amount);
			if(!ret)
			{
				std::cout << "Error deposit in DB\n";
				strcpy(response.data, "Server response: (ERROR) Processing operation");
				response.status = FAIL;
			}
			else 
			{
				response.status = SUCCESS;
				undostack_.pop();
				redostack_.push(undo_request);
			}
	    }
	}
	else if(type == REDO)
	{
		std::cout << "Client Redo Request\n";
		Request redo_request = redostack_.top();
		unsigned long long amount = std::stoll(redo_request.data);


	    if(redo_request.type == DEPOSIT)
	    {
	    	bool ret = deposit(amount);
			if(!ret)
			{
				std::cout << "Error deposit in DB\n";
				strcpy(response.data, "Server response: (ERROR) Processing operation");
				response.status = FAIL;
			}
			else 
			{
				response.status = SUCCESS;
				redostack_.pop();
			}
	    }
	    else if(redo_request.type == WITHDRAW)
	    {
			bool ret = withdraw(amount);
			if(!ret)
			{
				std::cout << "Error withdraw from DB\n";
				strcpy(response.data, "Server response: (ERROR) Processing operation");
				response.status = FAIL;
			}
			else 
			{
				response.status = SUCCESS;
				redostack_.pop();
			}
	    }
	}
	else if(type == BYE)
	{		
		std::cout << "Client exited!\n";
		return false;
	}

	return true;
}

bool ClientHandler::serveRequests(int sockfd)
{
	Response response;
	Request request;
	memset(response.data, 0, MSG_MAX_SIZE);
	memset(request.data, 0, MSG_MAX_SIZE);
	response.size = 0;
	request.size = 0;

	recvRequest(sockfd, request);

	bool exit = !processRequest(request, response);
	if(!exit)
	{
		sendResponse(sockfd, response);
		return true;
	}

	return false;
}
