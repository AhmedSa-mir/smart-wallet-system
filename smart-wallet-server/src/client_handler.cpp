#include "client_handler.h"

ClientHandler::ClientHandler(ThreadSafeQueue<Transaction>* loggingQueue)
{
	conn_ = mysql_init(NULL);
	
	// Connect to DB
	if(!mysql_real_connect(conn_, "localhost", "root", "root", "smart-wallet", 0, NULL, 0))
	{
		perror(mysql_error(conn_));
	}

	loggingQueue_ = loggingQueue;
}

ClientHandler::~ClientHandler()
{
	// Close DB connection
	mysql_free_result(res_);
	mysql_close(conn_);
}

int ClientHandler::getClientInfo(unsigned long national_id, ClientInfo& client_info)
{
	std::string query = "select * from customer where national_id = " + std::to_string(national_id);

	std::cout << "Query: " << query << std::endl;
	
	if(mysql_query(conn_, query.c_str()))
	{
		perror(mysql_error(conn_));
		return -1;
	}
	
	// Get query result
	res_ = mysql_store_result(conn_);

	unsigned int rows_cnt = mysql_num_rows(res_);
	if(rows_cnt != 1)
	{
		std::cout << "Error: " << rows_cnt << " rows with the same national_id\n";
		return -2;
	}
	else
	{
		row_ = mysql_fetch_row(res_);
		client_info.id = strtoul(row_[0], NULL, 10);
		client_info.name = row_[1];
		client_info.national_id = strtoul(row_[2], NULL, 10);
		client_info.age = atoi(row_[3]);
		client_info.balance = strtoull(row_[4], NULL, 10);

		std::cout << "id: " << client_info.id << std::endl;
		std::cout << "name: " << client_info.name  << std::endl;
		std::cout << "national_id: " << client_info.national_id << std::endl;
		std::cout << "age: " << client_info.age << std::endl;
		std::cout << "balance: " << client_info.balance << std::endl;
	}

	return 0;;
}

bool ClientHandler::isValidId(std::string id)
{
   return (id.find_first_not_of("0123456789") == std::string::npos)
            && (id.length() == 14);
}

bool ClientHandler::isValidAge(int age)
{
	// TODO: Check age correctly
	return (age > 18 && age < 200);
}

bool ClientHandler::createNewAccount(const ClientInfo& client_info)
{	
	std::string query = "insert into customer(name, national_id, age, gender, balance) "
					  	"values('" + client_info.name + "',"
					  	+ std::to_string(client_info.national_id) + ","
					  	+ std::to_string(client_info.age) + ",'"
					  	+ client_info.gender +"',0)";

	std::cout << "Query: " << query << std::endl;

	if(mysql_query(conn_, query.c_str()))
	{
		perror(mysql_error(conn_));
		return false;
	}

	// Store info in RAM
	client_info_ = client_info;

	// Get the autogenerated id after inserting row
	query = "select id from customer where national_id = "
		    + std::to_string(client_info.national_id);

	if(mysql_query(conn_, query.c_str()))
	{
		perror(mysql_error(conn_));
		return false;
	}

	// Get query result
	res_ = mysql_store_result(conn_);
	// res = mysql_use_result(conn);

	unsigned int rows_cnt = mysql_num_rows(res_);
	if(rows_cnt != 1)
	{
		std::cout << "Error: " << rows_cnt << " rows returned\n";
	}
	else
	{
		row_ = mysql_fetch_row(res_);
		client_info_.id = strtoul(row_[0], NULL, 10);

		std::cout << "Autogenerated id = " << client_info_.id << std::endl;
	}

	return true;
}

bool ClientHandler::deposit(unsigned long long amount)
{
	std::string query = "update customer set balance = balance + " + std::to_string(amount)
					  + " where id = " + std::to_string(client_info_.id);

	std::cout << "Query: " << query << std::endl;

	if(mysql_query(conn_, query.c_str()))
	{
		perror(mysql_error(conn_));
		return false;
	}

	// Push transaction to be logged by the logging thread
	Transaction transaction;
	transaction.id = client_info_.id;
	transaction.type = DEPOSIT;
	transaction.amount = amount;
	loggingQueue_->push(transaction);

	// Update data to be synced with DB
	client_info_.balance += amount;

	return true;
}

bool ClientHandler::withdraw(unsigned long long amount)
{
	std::string query = "update customer set balance = balance - " + std::to_string(amount)
					  + " where id = " + std::to_string(client_info_.id);

	std::cout << "Query: " << query << std::endl;
	
	if(mysql_query(conn_, query.c_str()))
	{
		perror(mysql_error(conn_));
		return false;
	}

	// Push transaction to be logged by the logging thread
	Transaction transaction;
	transaction.id = client_info_.id;
	transaction.type = WITHDRAW;
	transaction.amount = amount;
	loggingQueue_->push(transaction);

	// Update data to be synced with DB
	client_info_.balance -= amount;

	return true;
}

bool ClientHandler::getBalance(unsigned long long& balance)
{
	std::string query = "select balance from customer where id = "
					  + std::to_string(client_info_.id);

	std::cout << "Query: " << query << std::endl;

	if(mysql_query(conn_, query.c_str()))
	{
		perror(mysql_error(conn_));
		return false;
	}
	
	// Get query result
	res_ = mysql_store_result(conn_);
	// res = mysql_use_result(conn);

	unsigned int rows_cnt = mysql_num_rows(res_);
	if(rows_cnt != 1)
	{
		std::cout << "Error: " << rows_cnt << " rows with the same id\n";
		return false;
	}
	else
	{
		row_ = mysql_fetch_row(res_);
		balance = strtoull(row_[0], NULL, 10);

		if(client_info_.balance != balance)
		{
			std::cout << "Client balance = " << client_info_.balance
					  << "\nBalance stored in DB = " << balance << std::endl;
		}
		else
		{
			std::cout << "Balance = " << balance << std::endl;
		}
	}

	return true;
}

void ClientHandler::sendResponse(int sockfd, Response response)
{
	// Setup response (status + message data)
	std::string msg_data(response.data);
	std::string response_content = std::to_string(response.status) + " " + msg_data;
	
	// Send message size first
	sprintf(response.data,"%ld", response_content.length());

	int bytes_cnt = write(sockfd, response.data, sizeof(response.size));
	if (bytes_cnt < 0)
	{
		perror("Write Socket Error");
	}

	// Send message
	strcpy(response.data, response_content.c_str());
	response.size = response_content.length();

	bytes_cnt = write(sockfd, response.data, response.size);
	if (bytes_cnt < 0)
	{
		perror("Write Socket Error");
	}

	std::cout << "Response sent: " << response_content << std::endl;
}

void ClientHandler::recvRequest(int sockfd, Request& request)
{
	// Receive message size first
	int bytes_cnt = read(sockfd, request.data, sizeof(request.size));
	if (bytes_cnt < 0)
	{
		perror("Read Socket Error");
	}

	int msg_size = std::atoi(request.data);
	std::cout << "Client handler Received: " << msg_size << std::endl;

	// Receive message
	bytes_cnt = read(sockfd, request.data, msg_size);
	if (bytes_cnt < 0)
	{
		perror("Read Socket Error");
	}

	std::cout << "Client handler Received: " << request.data << std::endl;
}

bool ClientHandler::processRequest(Request request, Response& response)
{
	std::string data(request.data);

	// Split data by spaces
	std::istringstream iss(data);
	std::string msg_type, raw_data;
	std::getline(iss, msg_type, ' ');
	std::getline(iss, raw_data, ' ');

	std::cout << "Type received: " << msg_type << std::endl;

	REQUEST_TYPE type = REQUEST_TYPE(std::stoi(msg_type));
	if(type == LOGIN)
	{
		std::string national_id = raw_data;

		if(!isValidId(national_id))
		{
			std::cout << "Invalid id. National IDs are 14 characters!\n";
			response.status = INVALID_ID;
		}
		else
		{
			int ret = getClientInfo(std::stoul(national_id), client_info_);
			if(ret == -1)
			{
				std::cout << "Error getting client info from DB\n";
				strcpy(response.data, "Server response: (ERROR) Failure!");
				response.status = FAIL;
			}
			else if(ret == -2)
			{
				std::cout << "Error Client not registered\n";
				strcpy(response.data, "Server response: (ERROR) Client not registered!");
				response.status = FAIL;
			}
			else 
			{
				// Send success + client name
				response.status = SUCCESS;
				strcpy(response.data, client_info_.name.c_str());
				response.size = strlen(response.data);
			}
		}
	}
	else if(type == REGISTER)
	{
		std::string name, national_id, age, gender;
		name = raw_data;
		std::getline(iss, national_id, ' ');
		std::getline(iss, age, ' ');
		std::getline(iss, gender, ' ');

		std::cout << "name: " << name << std::endl;
		std::cout << "national_id: " << national_id << std::endl;
		std::cout << "age: " << age << std::endl;
		std::cout << "gender: " << gender << std::endl;

		if(!isValidId(national_id))
		{
			std::cout << "Invalid id. National IDs are 14 characters!\n";
			response.status = INVALID_ID;
		}
		else if(!isValidAge(std::stoi(age)))
		{
			std::cout << "Invalid age!\n";
			response.status = INVALID_AGE;
		}
		else
		{
			// Create new user
			ClientInfo client_info;
			client_info.name = name;
			client_info.national_id = std::stoul(national_id);
			client_info.age = stoi(age);
			client_info.balance = 0;
			client_info.gender = gender;

			bool ret = createNewAccount(client_info);
			if(!ret)
			{
				std::cout << "Error creating new account\n";
				strcpy(response.data, "Server response: (ERROR) Creating new account");
				response.status = FAIL;
			}
			else 
			{
				// Send success + client name
				response.status = SUCCESS;
				strcpy(response.data, client_info.name.c_str());
				response.size = strlen(response.data);
			}
		}
	}
	else if(type == DEPOSIT)
	{
		unsigned long long amount = std::stoll(raw_data);

		if (amount <= 0)
		{
			std::cout << "Invalid amount!\n";
			response.status = INVALID_AMOUNT;
		}
		else
		{
			bool ret = deposit(amount);
			if(!ret)
			{
				std::cout << "Error deposit in DB\n";
				strcpy(response.data, "Server response: (ERROR) Processing operation");
				response.status = FAIL;
			}
			else 
			{
				response.status = SUCCESS;
				request.type = type;
				strcpy(request.data, raw_data.c_str());
				undostack_.push(request);
			}
		}
	}
	else if(type == WITHDRAW)
	{
		unsigned long long amount = std::stoll(raw_data);

		if (amount <= 0)
		{
			std::cout << "Invalid amount!\n";
			response.status = INVALID_AMOUNT;
		}
		else
		{	
			// Check for balance first
			unsigned long long balance;
			bool ret = getBalance(balance);
			if(!ret)
			{
				std::cout << "Error getting balance from DB\n";
				strcpy(response.data, "Server response: (ERROR) Processing operation");
				response.status = FAIL;
			}
			else 
			{
				if(amount > balance)
				{
					std::cout << "Not enough money in your account!\n";
					response.status = NOT_ENOUGH_MONEY;
				}
				else
				{
					bool ret = withdraw(amount);
					if(!ret)
					{
						std::cout << "Error withdraw from DB\n";
						strcpy(response.data, "Server response: (ERROR) Processing operation");
						response.status = FAIL;
					}
					else 
					{
						response.status = SUCCESS;
						request.type = type;
						strcpy(request.data, raw_data.c_str());
						undostack_.push(request);
					}
				}
			}
		}
	}
	else if(type == CHECK_BALANCE)
	{
		unsigned long long balance;

		bool ret = getBalance(balance);
		if(!ret)
		{
			std::cout << "Error getting balance from DB\n";
			strcpy(response.data, "Server response: (ERROR) Processing operation");
			response.status = FAIL;
		}
		else 
		{
			// Send success + balance
			response.status = SUCCESS;
			strcpy(response.data,  std::to_string(balance).c_str());
			response.size = strlen(response.data);
		}
	}
	else if(type == UNDO)
	{
		Request undo_request = undostack_.top();
		unsigned long long amount = std::stoll(undo_request.data);
	    
	    if(undo_request.type == DEPOSIT)
	    {
	        bool ret = withdraw(amount);
			if(!ret)
			{
				std::cout << "Error withdraw from DB\n";
				strcpy(response.data, "Server response: (ERROR) Processing operation");
				response.status = FAIL;
			}
			else 
			{
				response.status = SUCCESS;
				undostack_.pop();
				redostack_.push(undo_request);
			}
	    }
	    else if(undo_request.type == WITHDRAW)
	    {
	        bool ret = deposit(amount);
			if(!ret)
			{
				std::cout << "Error deposit in DB\n";
				strcpy(response.data, "Server response: (ERROR) Processing operation");
				response.status = FAIL;
			}
			else 
			{
				response.status = SUCCESS;
				undostack_.pop();
				redostack_.push(undo_request);
			}
	    }
	}
	else if(type == REDO)
	{
		Request redo_request = redostack_.top();
		unsigned long long amount = std::stoll(redo_request.data);


	    if(redo_request.type == DEPOSIT)
	    {
	    	bool ret = deposit(amount);
			if(!ret)
			{
				std::cout << "Error deposit in DB\n";
				strcpy(response.data, "Server response: (ERROR) Processing operation");
				response.status = FAIL;
			}
			else 
			{
				response.status = SUCCESS;
				redostack_.pop();
			}
	    }
	    else if(redo_request.type == WITHDRAW)
	    {
			bool ret = withdraw(amount);
			if(!ret)
			{
				std::cout << "Error withdraw from DB\n";
				strcpy(response.data, "Server response: (ERROR) Processing operation");
				response.status = FAIL;
			}
			else 
			{
				response.status = SUCCESS;
				redostack_.pop();
			}
	    }
	}
	else if(type == BYE)
	{		
		std::cout << "Client exited!\n";
		return false;
	}

	return true;
}

bool ClientHandler::serveRequests(int sockfd)
{
	Response response;
	Request request;
	memset(response.data, 0, MSG_MAX_SIZE);
	memset(request.data, 0, MSG_MAX_SIZE);
	response.size = 0;
	request.size = 0;

	recvRequest(sockfd, request);

	bool exit = !processRequest(request, response);
	if(!exit)
	{
		sendResponse(sockfd, response);
		return true;
	}

	return false;
}